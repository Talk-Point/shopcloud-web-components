{"version":3,"names":["scQueryFieldCss","ScQueryFieldStyle0","ScQueryField","this","handleOutsideClick","event","hostElement","contains","target","contextMenuVisible","handleKeyDownEscape","key","componentWillLoad","fields","parsed","JSON","parse","Array","isArray","console","warn","error","componentDidLoad","hiddenInput","document","createElement","type","name","appendChild","addEventListener","disconnectedCallback","removeEventListener","handleInputFocus","updateSuggestions","handleInputChange","inputValue","value","handleKeyDown","trim","valid","validateInput","addFilter","querySubmit","emit","getQueryValue","alert","handleSuggestionClick","suggestion","parts","split","currentStep","inputRef","focus","filter","length","fieldName","operator","fieldArray","field","find","f","quotedValue","replace","filters","emitQueryChange","removeFilter","index","_","i","query","queryChange","join","prefix","toLowerCase","suggestions","map","startsWith","getOperatorsForType","getValuesForType","input","includes","validateValueForType","isNaN","Number","render","h","class","ref","el","inputClass","onFocus","onInput","onKeyDown","placeholder","onClick","scTaxonomyCss","ScTaxonomyStyle0","ScTaxonomy","root","shadowRoot","handleEscapeKey","handleValueChange","newValue","valueChange","url","fetchData","response","fetch","text","allData","line","clearTimeout","debounceTimer","window","setTimeout","term","lowerTerm","filtered","slice","scTextareaCss","ScTextareaStyle0","ScTextarea","top","left","suggestionUrl","lines","s","original","lower","ev","showSuggestions","preventDefault","highlightIndex","filteredSuggestions","selectSuggestion","handleInput","e","currentInputValue","caretPos","selectionStart","valueUpToCaret","substring","lastAt","lastIndexOf","mentionStartIndex","updateMirror","mirrorDiv","textareaEl","valueAfterCaret","escapedValueUpToCaret","mirrorContent","innerHTML","marker","querySelector","markerRect","getBoundingClientRect","containerRect","host","caretCoords","beforeMention","afterCaret","newCaretPos","setSelectionRange","textareaClass","style","position","role","item","highlighted","onMouseOver"],"sources":["src/components/sc-query-field/sc-query-field.css?tag=sc-query-field&encapsulation=shadow","src/components/sc-query-field/sc-query-field.tsx","src/components/sc-taxonomy/sc-taxonomy.css?tag=sc-taxonomy&encapsulation=shadow","src/components/sc-taxonomy/sc-taxonomy.tsx","src/components/sc-textarea/sc-textarea.css?tag=sc-textarea&encapsulation=shadow","src/components/sc-textarea/sc-textarea.tsx"],"sourcesContent":[".query-field {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n  font-family: sans-serif;\n}\n\n.tags {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 0.5rem;\n}\n\n.tag {\n  background-color: #1f4acd;\n  color: white;\n  padding: 0.25rem 0.5rem;\n  border-radius: 1rem;\n  display: inline-flex;\n  align-items: center;\n  gap: 0.25rem;\n  font-size: 0.875rem;\n}\n\n.remove-button {\n  background: none;\n  border: none;\n  color: white;\n  font-size: 1rem;\n  cursor: pointer;\n}\n\n.input-wrapper {\n  position: relative;\n}\n\n.query-input {\n  width: 100%;\n  padding: 0.5rem;\n  border: 1px solid #ccc;\n  border-radius: 0.375rem;\n  font-size: 1rem;\n  outline: none;\n}\n\n.query-input:focus {\n  border-color: #1f4acd;\n}\n\n.context-menu {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  background: #fff;\n  border: 1px solid #ccc;\n  border-radius: 0.375rem;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  width: 100%;\n  z-index: 100;\n  display: none;\n  margin-top: 0.25rem;\n}\n\n.context-menu.visible {\n  display: block;\n}\n\n.suggestion {\n  padding: 0.5rem;\n  cursor: pointer;\n  font-size: 0.9rem;\n}\n\n.suggestion:hover {\n  background-color: #f3f4f6;\n}","import { Component, h, State, Prop, Event, EventEmitter, Element } from '@stencil/core';\n\n@Component({\n  tag: 'sc-query-field',\n  styleUrl: 'sc-query-field.css',\n  shadow: true,\n})\nexport class ScQueryField {\n  @State() filters: string[] = [];\n  @State() inputValue: string = '';\n  @State() suggestions: string[] = [];\n  @State() currentStep: 'field' | 'operator' | 'value' = 'field';\n  @State() contextMenuVisible: boolean = false;\n\n  /**\n   * Fields can be passed as a JSON string or a parsed array of field definitions.\n   */\n  @Prop() fields: string | FieldDefinition[] = [];\n\n  /**\n   * Optional class for the input field.\n   */\n  @Prop() inputClass: string; // Optional class for textarea\n\n  /**\n   * Emitted whenever the query changes. The detail contains the current query string.\n   */\n  @Event() queryChange: EventEmitter<string>;\n\n  /**\n   * Emitted when the user submits the query (e.g., pressing Enter on a complete filter).\n   * The detail contains the final query string.\n   */\n  @Event() querySubmit: EventEmitter<string>;\n\n  @Element() hostElement: HTMLElement;\n  hiddenInput!: HTMLInputElement;\n  inputRef!: HTMLInputElement;\n\n  componentWillLoad() {\n    // Parse fields if it's a JSON string\n    if (typeof this.fields === 'string') {\n      try {\n        const parsed = JSON.parse(this.fields);\n        if (Array.isArray(parsed)) {\n          this.fields = parsed;\n        } else {\n          console.warn('Invalid fields prop: expected an array.');\n          this.fields = [];\n        }\n      } catch (error) {\n        console.error('Error parsing fields prop:', error);\n        this.fields = [];\n      }\n    }\n  }\n\n  componentDidLoad() {\n    // Create a hidden input to integrate with form submissions\n    this.hiddenInput = document.createElement('input');\n    this.hiddenInput.type = 'hidden';\n    this.hiddenInput.name = 'query';\n    this.hostElement.appendChild(this.hiddenInput);\n\n    // Close context menu on outside click\n    document.addEventListener('click', this.handleOutsideClick);\n    // Close context menu on ESC\n    document.addEventListener('keydown', this.handleKeyDownEscape);\n  }\n\n  disconnectedCallback() {\n    document.removeEventListener('click', this.handleOutsideClick);\n    document.removeEventListener('keydown', this.handleKeyDownEscape);\n  }\n\n  handleOutsideClick = (event: MouseEvent) => {\n    if (!this.hostElement.contains(event.target as Node)) {\n      this.contextMenuVisible = false;\n    }\n  };\n\n  handleKeyDownEscape = (event: KeyboardEvent) => {\n    if (event.key === 'Escape') {\n      this.contextMenuVisible = false;\n    }\n  };\n\n  handleInputFocus() {\n    this.updateSuggestions();\n    this.contextMenuVisible = true;\n  }\n\n  handleInputChange(event: Event) {\n    this.inputValue = (event.target as HTMLInputElement).value;\n    this.updateSuggestions();\n  }\n\n  handleKeyDown(event: KeyboardEvent) {\n    if (event.key === 'Enter' && this.inputValue.trim() !== '') {\n      const valid = this.validateInput(this.inputValue.trim());\n      if (valid) {\n        // Add the filter; if it's a string field, the value will be quoted inside addFilter().\n        this.addFilter(this.inputValue.trim());\n        this.inputValue = '';\n        this.contextMenuVisible = false;\n        // Emit querySubmit when a valid filter is added via Enter\n        this.querySubmit.emit(this.getQueryValue());\n      } else {\n        alert('Invalid filter. Use format: field:operator:value');\n      }\n    }\n  }\n\n  handleSuggestionClick(suggestion: string) {\n    const parts = this.inputValue.split(':');\n    if (this.currentStep === 'field') {\n      this.inputValue = `${suggestion}:`;\n    } else if (this.currentStep === 'operator') {\n      this.inputValue = `${parts[0]}:${suggestion}:`;\n    } else if (this.currentStep === 'value') {\n      this.inputValue = `${parts[0]}:${parts[1]}:${suggestion}`;\n    }\n    this.updateSuggestions();\n    this.inputRef.focus();\n  }\n\n  addFilter(filter: string) {\n    // If the field is string type, wrap the value in quotes\n    const parts = filter.split(':');\n    if (parts.length === 3) {\n      const [fieldName, operator, value] = parts;\n      const fieldArray = this.fields as FieldDefinition[];\n      const field = fieldArray.find(f => f.name === fieldName);\n\n      if (field && field.type === 'string') {\n        // Ensure the value is quoted\n        // Remove existing quotes if any, then add single quotes\n        const quotedValue = `'${value.replace(/^'|'$/g, '')}'`;\n        filter = `${fieldName}:${operator}:${quotedValue}`;\n      }\n    }\n\n    this.filters = [...this.filters, filter];\n    this.emitQueryChange();\n  }\n\n  removeFilter(index: number) {\n    this.filters = this.filters.filter((_, i) => i !== index);\n    this.emitQueryChange();\n  }\n\n  emitQueryChange() {\n    const query = this.getQueryValue();\n    this.queryChange.emit(query);\n    if (this.hiddenInput) {\n      this.hiddenInput.value = query;\n    }\n  }\n\n  getQueryValue(): string {\n    return this.filters.join(' ');\n  }\n\n  updateSuggestions() {\n    const parts = this.inputValue.split(':');\n    const fieldArray = this.fields as FieldDefinition[];\n\n    if (parts.length === 1) {\n      // Step: Selecting Field\n      this.currentStep = 'field';\n      const prefix = parts[0].toLowerCase();\n      this.suggestions = fieldArray.map(f => f.name).filter(name => prefix === '' || name.toLowerCase().startsWith(prefix));\n    } else if (parts.length === 2) {\n      // Step: Selecting Operator\n      this.currentStep = 'operator';\n      const field = fieldArray.find(f => f.name === parts[0]);\n      if (field) {\n        this.suggestions = this.getOperatorsForType(field.type);\n      } else {\n        this.suggestions = [];\n      }\n    } else if (parts.length === 3) {\n      // Step: Selecting Value\n      this.currentStep = 'value';\n      const field = fieldArray.find(f => f.name === parts[0]);\n      if (field) {\n        this.suggestions = this.getValuesForType(field.type);\n      } else {\n        this.suggestions = [];\n      }\n    } else {\n      this.suggestions = [];\n    }\n\n    this.contextMenuVisible = this.suggestions.length > 0;\n  }\n\n  validateInput(input: string): boolean {\n    const parts = input.split(':');\n    if (parts.length === 3) {\n      const [fieldName, operator, value] = parts;\n      const fieldArray = this.fields as FieldDefinition[];\n      const field = fieldArray.find(f => f.name === fieldName);\n      if (!field) return false;\n\n      if (!this.getOperatorsForType(field.type).includes(operator)) return false;\n\n      return this.validateValueForType(value, field.type);\n    }\n    return false;\n  }\n\n  getOperatorsForType(type: FieldType): string[] {\n    switch (type) {\n      case 'string':\n        return ['LIKE', '=', '!=', 'null', 'notnull'];\n      case 'bool':\n        return ['=', 'null', 'notnull'];\n      case 'number':\n        return ['>', '<', '>=', '<=', '='];\n      default:\n        return [];\n    }\n  }\n\n  getValuesForType(type: FieldType): string[] {\n    // Example static suggestions. In a real-world scenario, you might fetch these dynamically.\n    switch (type) {\n      case 'string':\n        return ['test', 'example'];\n      case 'bool':\n        return ['true', 'false'];\n      case 'number':\n        return ['0', '100', '200'];\n      default:\n        return [];\n    }\n  }\n\n  validateValueForType(value: string, type: FieldType): boolean {\n    // The user enters value without quotes initially\n    switch (type) {\n      case 'string':\n        // Just ensure it's a string (non-empty)\n        return typeof value === 'string' && value.trim() !== '';\n      case 'bool':\n        return value === 'true' || value === 'false';\n      case 'number':\n        return !isNaN(Number(value));\n      default:\n        return false;\n    }\n  }\n\n  render() {\n    return (\n      <div class=\"query-field\">\n        <div class=\"input-wrapper\">\n          <input\n            type=\"text\"\n            ref={el => (this.inputRef = el as HTMLInputElement)}\n            class={`query-input ${this.inputClass}`}\n            value={this.inputValue}\n            onFocus={() => this.handleInputFocus()}\n            onInput={event => this.handleInputChange(event)}\n            onKeyDown={event => this.handleKeyDown(event)}\n            placeholder=\"Add filters (field:operator:value)\"\n          />\n          <div class={`context-menu ${this.contextMenuVisible ? 'visible' : ''}`}>\n            {this.suggestions.map(suggestion => (\n              <div class=\"suggestion\" onClick={() => this.handleSuggestionClick(suggestion)}>\n                {suggestion}\n              </div>\n            ))}\n          </div>\n        </div>\n        <div class=\"tags\">\n          {this.filters.map((filter, index) => (\n            <span class=\"tag\">\n              {filter}\n              <button type=\"button\" class=\"remove-button\" onClick={() => this.removeFilter(index)}>\n                &times;\n              </button>\n            </span>\n          ))}\n        </div>\n      </div>\n    );\n  }\n}\n",".taxonomy-container {\n  position: relative;\n  display: inline-block;\n  width: 100%;\n}\n\n.input-wrapper {\n  position: relative;\n}\n\n.taxonomy-input {\n  width: 100%;\n  box-sizing: border-box;\n  padding: 8px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n}\n\n.context-menu {\n  position: absolute;\n  top: 100%; /* directly below input */\n  left: 0;\n  width: 100%;\n  box-sizing: border-box;\n  border: 1px solid #ccc;\n  background: #fff;\n  z-index: 999;\n  max-height: 400px;\n  overflow-y: auto;\n  display: none;\n}\n\n.context-menu.visible {\n  display: block;\n}\n\n.suggestion {\n  padding: 8px;\n  cursor: pointer;\n}\n\n.suggestion:hover {\n  background: #eee;\n}","import { Component, h, State, Prop, Element, Event, EventEmitter } from '@stencil/core';\n\n@Component({\n  tag: 'sc-taxonomy',\n  styleUrl: 'sc-taxonomy.css',\n  shadow: true,\n})\nexport class ScTaxonomy {\n  @Prop() url: string;\n  @Prop() name: string;\n  @Prop() value: string; // Add this line\n\n  @State() inputValue: string = '';\n  @State() suggestions: string[] = [];\n  @State() allData: string[] = [];\n  @State() contextMenuVisible: boolean = false;\n\n  @Element() hostElement: HTMLElement;\n  inputRef!: HTMLInputElement;\n\n  @Event() valueChange: EventEmitter<string>;\n\n  handleValueChange(newValue: string) {\n    this.valueChange.emit(newValue);\n  }\n\n  private debounceTimer: number;\n\n  async componentWillLoad() {\n    if (this.url) {\n      await this.fetchData();\n    }\n    if (this.value) {\n      this.inputValue = this.value; // Set the initial value\n    }\n  }\n\n  componentDidLoad() {\n    document.addEventListener('click', this.handleOutsideClick);\n    document.addEventListener('keydown', this.handleEscapeKey);\n  }\n\n  disconnectedCallback() {\n    document.removeEventListener('click', this.handleOutsideClick);\n    document.removeEventListener('keydown', this.handleEscapeKey);\n  }\n\n  private handleOutsideClick = (event: MouseEvent) => {\n    const root = this.hostElement.shadowRoot;\n    if (root && !root.contains(event.target as Node)) {\n      this.contextMenuVisible = false;\n    }\n  };\n\n  private handleEscapeKey = (event: KeyboardEvent) => {\n    if (event.key === 'Escape') {\n      this.contextMenuVisible = false;\n    }\n  };\n\n  async fetchData() {\n    try {\n      const response = await fetch(this.url);\n      const text = await response.text();\n      this.allData = text\n        .split('\\n')\n        .map(line => line.trim())\n        .filter(line => line !== '');\n    } catch (error) {\n      console.error('Error fetching data:', error);\n      this.allData = [];\n    }\n  }\n\n  handleInputFocus() {\n    // On focus, don't show suggestions if empty. Wait until user types.\n    if (this.inputValue.length > 0) {\n      this.updateSuggestions(this.inputValue);\n    }\n  }\n\n  handleInputChange(event: Event) {\n    const value = (event.target as HTMLInputElement).value;\n    this.inputValue = value;\n\n    clearTimeout(this.debounceTimer);\n    this.debounceTimer = window.setTimeout(() => {\n      this.updateSuggestions(value);\n    }, 100);\n  }\n\n  handleKeyDown(event: KeyboardEvent) {\n    if (event.key === 'Enter') {\n      // Close the menu on Enter if you wish:\n      // this.contextMenuVisible = false;\n    }\n  }\n\n  handleSuggestionClick(suggestion: string) {\n    this.inputValue = suggestion;\n    this.handleValueChange(suggestion);\n    this.inputRef.value = suggestion;\n    this.inputRef.focus();\n  }\n\n  updateSuggestions(term: string) {\n    if (term.trim().length === 0) {\n      // If no input, no suggestions\n      this.suggestions = [];\n      this.contextMenuVisible = false;\n    } else {\n      const lowerTerm = term.toLowerCase();\n      const filtered = this.allData.filter(line => line.toLowerCase().includes(lowerTerm));\n      // Limit the number of suggestions for performance if needed:\n      this.suggestions = filtered.slice(0, 100);\n      this.contextMenuVisible = this.suggestions.length > 0;\n    }\n  }\n\n  render() {\n    return (\n      <div class=\"taxonomy-container\">\n        <div class=\"input-wrapper\">\n          <input\n            type=\"text\"\n            ref={el => (this.inputRef = el as HTMLInputElement)}\n            class=\"taxonomy-input\"\n            name={this.name}\n            value={this.inputValue}\n            onFocus={() => this.handleInputFocus()}\n            onInput={event => this.handleInputChange(event)}\n            onKeyDown={event => this.handleKeyDown(event)}\n            placeholder=\"Type to search...\"\n          />\n          <div class={`context-menu ${this.contextMenuVisible ? 'visible' : ''}`}>\n            {this.suggestions.map(suggestion => (\n              <div class=\"suggestion\" onClick={() => this.handleSuggestionClick(suggestion)}>\n                {suggestion}\n              </div>\n            ))}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n",":host {\n  display: inline-block;\n  position: relative;\n  width: 300px;\n  font-size: 14px;\n  font-family: sans-serif;\n}\n\n.sc-textarea-container {\n  position: relative;\n  width: 100%;\n}\n\n/* Textarea */\n.sc-textarea-input {\n  width: 100%;\n  height: 100px;\n  box-sizing: border-box;\n  padding: 5px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  font: inherit;\n}\n\n/* Mirror to calculate caret position */\n.sc-textarea-mirror {\n  position: absolute;\n  visibility: hidden;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  overflow-wrap: break-word;\n  top: 0;\n  left: 0;\n  z-index: -9999;\n  font: inherit;\n  line-height: normal;\n  width: 100%;\n  padding: 5px;\n  border: 1px solid transparent;\n  box-sizing: border-box;\n}\n\n/* Suggestions Menu */\n.sc-textarea-suggestions {\n  background: #fff;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  max-height: 200px;\n  overflow-y: auto;\n  z-index: 999;\n}\n\n.sc-textarea-suggestion-item {\n  padding: 5px 8px;\n  cursor: pointer;\n  font-size: 14px;\n  font-family: sans-serif;\n}\n\n.sc-textarea-suggestion-item:hover,\n.sc-textarea-suggestion-item.highlighted {\n  background-color: #eee;\n}","import { Component, h, State, Prop, Listen, Element } from '@stencil/core';\n\n@Component({\n  tag: 'sc-textarea',\n  styleUrl: 'sc-textarea.css',\n  shadow: true\n})\nexport class ScTextarea {\n  @Prop() suggestionUrl: string;\n  @Prop() textareaClass: string; // Optional class for textarea\n\n  @State() suggestions: { original: string; lower: string }[] = [];\n  @State() filteredSuggestions: string[] = [];\n  @State() showSuggestions: boolean = false;\n  @State() currentInputValue: string = '';\n  @State() mentionStartIndex: number = -1;\n  @State() highlightIndex: number = 0;\n  @State() caretCoords: { top: number; left: number } = { top: 0, left: 0 };\n\n  @Element() el: HTMLElement;\n\n  private textareaEl: HTMLTextAreaElement;\n  private mirrorDiv: HTMLDivElement;\n\n  async componentWillLoad() {\n    const response = await fetch(this.suggestionUrl);\n    const text = await response.text();\n    const lines = text\n      .split('\\n')\n      .map(s => s.trim())\n      .filter(s => s.length > 0);\n\n    // Pre-store lowercase versions for faster filtering\n    this.suggestions = lines.map(s => ({ original: s, lower: s.toLowerCase() }));\n  }\n\n  @Listen('keydown', { target: 'window' })\n  handleKeyDown(ev: KeyboardEvent) {\n    if (!this.showSuggestions) return;\n    if (ev.key === 'ArrowDown') {\n      ev.preventDefault();\n      this.highlightIndex = (this.highlightIndex + 1) % this.filteredSuggestions.length;\n    } else if (ev.key === 'ArrowUp') {\n      ev.preventDefault();\n      this.highlightIndex = (this.highlightIndex - 1 + this.filteredSuggestions.length) % this.filteredSuggestions.length;\n    } else if (ev.key === 'Enter') {\n      ev.preventDefault();\n      this.selectSuggestion(this.filteredSuggestions[this.highlightIndex]);\n    } else if (ev.key === 'Escape') {\n      this.showSuggestions = false;\n    }\n  }\n\n  handleInput(e: Event) {\n    const target = e.target as HTMLTextAreaElement;\n    this.currentInputValue = target.value;\n\n    const caretPos = target.selectionStart;\n    const valueUpToCaret = target.value.substring(0, caretPos);\n    const lastAt = valueUpToCaret.lastIndexOf('@');\n\n    if (lastAt > -1) {\n      const query = valueUpToCaret.substring(lastAt + 1).toLowerCase();\n      // Filter suggestions (limit to top 10 for performance)\n      const filtered = this.suggestions\n        .filter(s => s.lower.startsWith(query))\n        .slice(0, 10)\n        .map(s => s.original);\n\n      this.filteredSuggestions = filtered;\n      this.showSuggestions = filtered.length > 0;\n      this.mentionStartIndex = lastAt;\n      this.highlightIndex = 0;\n    } else {\n      this.showSuggestions = false;\n    }\n\n    // Update mirror for caret positioning\n    this.updateMirror();\n  }\n\n  updateMirror() {\n    if (!this.mirrorDiv || !this.textareaEl) return;\n\n    const value = this.currentInputValue;\n    const caretPos = this.textareaEl.selectionStart;\n    const valueUpToCaret = value.substring(0, caretPos);\n    const valueAfterCaret = value.substring(caretPos);\n\n    // We insert a caret marker span at the caret position in the mirrored text\n    const escapedValueUpToCaret = valueUpToCaret\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\\n/g, '<br/> ');\n\n    // Use a marker to indicate caret position\n    const mirrorContent = escapedValueUpToCaret + '<span id=\"caret-marker\">&#8203;</span>' +\n      valueAfterCaret\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\\n/g, '<br/> ');\n\n    this.mirrorDiv.innerHTML = mirrorContent;\n\n    // Now measure the caret position\n    const marker = this.mirrorDiv.querySelector('#caret-marker') as HTMLElement;\n    if (marker) {\n      const markerRect = marker.getBoundingClientRect();\n      const containerRect = this.el.shadowRoot.host.getBoundingClientRect();\n      this.caretCoords = {\n        top: markerRect.top - containerRect.top,\n        left: markerRect.left - containerRect.left\n      };\n    }\n  }\n\n  selectSuggestion(suggestion: string) {\n    const value = this.currentInputValue;\n    const beforeMention = value.substring(0, this.mentionStartIndex);\n    const caretPos = this.textareaEl.selectionStart;\n    const afterCaret = value.substring(caretPos);\n    const newValue = beforeMention + '@' + suggestion + ' ' + afterCaret;\n    this.currentInputValue = newValue;\n    this.showSuggestions = false;\n\n    const newCaretPos = (beforeMention + '@' + suggestion + ' ').length;\n    this.textareaEl.value = newValue;\n    this.textareaEl.setSelectionRange(newCaretPos, newCaretPos);\n    this.textareaEl.focus();\n    this.updateMirror();\n  }\n\n  componentDidLoad() {\n    // Initialize mirror once component is loaded\n    this.updateMirror();\n  }\n\n  render() {\n    const { top, left } = this.caretCoords;\n    return (\n      <div class=\"sc-textarea-container\">\n        <textarea\n          ref={el => this.textareaEl = el}\n          value={this.currentInputValue}\n          onInput={(e) => this.handleInput(e)}\n          class={`sc-textarea-input ${this.textareaClass}`}\n        ></textarea>\n\n        <div class=\"sc-textarea-mirror\" ref={el => this.mirrorDiv = el}></div>\n\n        { this.showSuggestions && this.filteredSuggestions.length > 0 && (\n          <ul \n            class=\"sc-textarea-suggestions\"\n            style={{\n              position: 'absolute',\n              top: `${top + 20}px`, // Slight offset below the cursor\n              left: `${left}px`\n            }} \n            role=\"listbox\"\n          >\n            {this.filteredSuggestions.map((item, index) => (\n              <li \n                class={{\n                  'sc-textarea-suggestion-item': true,\n                  'highlighted': index === this.highlightIndex\n                }}\n                role=\"option\"\n                onClick={() => this.selectSuggestion(item)}\n                onMouseOver={() => this.highlightIndex = index}\n              >\n                {item}\n              </li>\n            ))}\n          </ul>\n        )}\n      </div>\n    );\n  }\n}"],"mappings":"yDAAA,MAAMA,EAAkB,g4BACxB,MAAAC,EAAeD,E,MCMFE,EAAY,M,2GAoEvBC,KAAAC,mBAAsBC,IACpB,IAAKF,KAAKG,YAAYC,SAASF,EAAMG,QAAiB,CACpDL,KAAKM,mBAAqB,K,GAI9BN,KAAAO,oBAAuBL,IACrB,GAAIA,EAAMM,MAAQ,SAAU,CAC1BR,KAAKM,mBAAqB,K,gBA3ED,G,gBACC,G,iBACG,G,iBACsB,Q,wBAChB,M,YAKM,G,0BAsB7C,iBAAAG,GAEE,UAAWT,KAAKU,SAAW,SAAU,CACnC,IACE,MAAMC,EAASC,KAAKC,MAAMb,KAAKU,QAC/B,GAAII,MAAMC,QAAQJ,GAAS,CACzBX,KAAKU,OAASC,C,KACT,CACLK,QAAQC,KAAK,2CACbjB,KAAKU,OAAS,E,EAEhB,MAAOQ,GACPF,QAAQE,MAAM,6BAA8BA,GAC5ClB,KAAKU,OAAS,E,GAKpB,gBAAAS,GAEEnB,KAAKoB,YAAcC,SAASC,cAAc,SAC1CtB,KAAKoB,YAAYG,KAAO,SACxBvB,KAAKoB,YAAYI,KAAO,QACxBxB,KAAKG,YAAYsB,YAAYzB,KAAKoB,aAGlCC,SAASK,iBAAiB,QAAS1B,KAAKC,oBAExCoB,SAASK,iBAAiB,UAAW1B,KAAKO,oB,CAG5C,oBAAAoB,GACEN,SAASO,oBAAoB,QAAS5B,KAAKC,oBAC3CoB,SAASO,oBAAoB,UAAW5B,KAAKO,oB,CAe/C,gBAAAsB,GACE7B,KAAK8B,oBACL9B,KAAKM,mBAAqB,I,CAG5B,iBAAAyB,CAAkB7B,GAChBF,KAAKgC,WAAc9B,EAAMG,OAA4B4B,MACrDjC,KAAK8B,mB,CAGP,aAAAI,CAAchC,GACZ,GAAIA,EAAMM,MAAQ,SAAWR,KAAKgC,WAAWG,SAAW,GAAI,CAC1D,MAAMC,EAAQpC,KAAKqC,cAAcrC,KAAKgC,WAAWG,QACjD,GAAIC,EAAO,CAETpC,KAAKsC,UAAUtC,KAAKgC,WAAWG,QAC/BnC,KAAKgC,WAAa,GAClBhC,KAAKM,mBAAqB,MAE1BN,KAAKuC,YAAYC,KAAKxC,KAAKyC,gB,KACtB,CACLC,MAAM,mD,GAKZ,qBAAAC,CAAsBC,GACpB,MAAMC,EAAQ7C,KAAKgC,WAAWc,MAAM,KACpC,GAAI9C,KAAK+C,cAAgB,QAAS,CAChC/C,KAAKgC,WAAa,GAAGY,I,MAChB,GAAI5C,KAAK+C,cAAgB,WAAY,CAC1C/C,KAAKgC,WAAa,GAAGa,EAAM,MAAMD,I,MAC5B,GAAI5C,KAAK+C,cAAgB,QAAS,CACvC/C,KAAKgC,WAAa,GAAGa,EAAM,MAAMA,EAAM,MAAMD,G,CAE/C5C,KAAK8B,oBACL9B,KAAKgD,SAASC,O,CAGhB,SAAAX,CAAUY,GAER,MAAML,EAAQK,EAAOJ,MAAM,KAC3B,GAAID,EAAMM,SAAW,EAAG,CACtB,MAAOC,EAAWC,EAAUpB,GAASY,EACrC,MAAMS,EAAatD,KAAKU,OACxB,MAAM6C,EAAQD,EAAWE,MAAKC,GAAKA,EAAEjC,OAAS4B,IAE9C,GAAIG,GAASA,EAAMhC,OAAS,SAAU,CAGpC,MAAMmC,EAAc,IAAIzB,EAAM0B,QAAQ,SAAU,OAChDT,EAAS,GAAGE,KAAaC,KAAYK,G,EAIzC1D,KAAK4D,QAAU,IAAI5D,KAAK4D,QAASV,GACjClD,KAAK6D,iB,CAGP,YAAAC,CAAaC,GACX/D,KAAK4D,QAAU5D,KAAK4D,QAAQV,QAAO,CAACc,EAAGC,IAAMA,IAAMF,IACnD/D,KAAK6D,iB,CAGP,eAAAA,GACE,MAAMK,EAAQlE,KAAKyC,gBACnBzC,KAAKmE,YAAY3B,KAAK0B,GACtB,GAAIlE,KAAKoB,YAAa,CACpBpB,KAAKoB,YAAYa,MAAQiC,C,EAI7B,aAAAzB,GACE,OAAOzC,KAAK4D,QAAQQ,KAAK,I,CAG3B,iBAAAtC,GACE,MAAMe,EAAQ7C,KAAKgC,WAAWc,MAAM,KACpC,MAAMQ,EAAatD,KAAKU,OAExB,GAAImC,EAAMM,SAAW,EAAG,CAEtBnD,KAAK+C,YAAc,QACnB,MAAMsB,EAASxB,EAAM,GAAGyB,cACxBtE,KAAKuE,YAAcjB,EAAWkB,KAAIf,GAAKA,EAAEjC,OAAM0B,QAAO1B,GAAQ6C,IAAW,IAAM7C,EAAK8C,cAAcG,WAAWJ,I,MACxG,GAAIxB,EAAMM,SAAW,EAAG,CAE7BnD,KAAK+C,YAAc,WACnB,MAAMQ,EAAQD,EAAWE,MAAKC,GAAKA,EAAEjC,OAASqB,EAAM,KACpD,GAAIU,EAAO,CACTvD,KAAKuE,YAAcvE,KAAK0E,oBAAoBnB,EAAMhC,K,KAC7C,CACLvB,KAAKuE,YAAc,E,OAEhB,GAAI1B,EAAMM,SAAW,EAAG,CAE7BnD,KAAK+C,YAAc,QACnB,MAAMQ,EAAQD,EAAWE,MAAKC,GAAKA,EAAEjC,OAASqB,EAAM,KACpD,GAAIU,EAAO,CACTvD,KAAKuE,YAAcvE,KAAK2E,iBAAiBpB,EAAMhC,K,KAC1C,CACLvB,KAAKuE,YAAc,E,MAEhB,CACLvE,KAAKuE,YAAc,E,CAGrBvE,KAAKM,mBAAqBN,KAAKuE,YAAYpB,OAAS,C,CAGtD,aAAAd,CAAcuC,GACZ,MAAM/B,EAAQ+B,EAAM9B,MAAM,KAC1B,GAAID,EAAMM,SAAW,EAAG,CACtB,MAAOC,EAAWC,EAAUpB,GAASY,EACrC,MAAMS,EAAatD,KAAKU,OACxB,MAAM6C,EAAQD,EAAWE,MAAKC,GAAKA,EAAEjC,OAAS4B,IAC9C,IAAKG,EAAO,OAAO,MAEnB,IAAKvD,KAAK0E,oBAAoBnB,EAAMhC,MAAMsD,SAASxB,GAAW,OAAO,MAErE,OAAOrD,KAAK8E,qBAAqB7C,EAAOsB,EAAMhC,K,CAEhD,OAAO,K,CAGT,mBAAAmD,CAAoBnD,GAClB,OAAQA,GACN,IAAK,SACH,MAAO,CAAC,OAAQ,IAAK,KAAM,OAAQ,WACrC,IAAK,OACH,MAAO,CAAC,IAAK,OAAQ,WACvB,IAAK,SACH,MAAO,CAAC,IAAK,IAAK,KAAM,KAAM,KAChC,QACE,MAAO,G,CAIb,gBAAAoD,CAAiBpD,GAEf,OAAQA,GACN,IAAK,SACH,MAAO,CAAC,OAAQ,WAClB,IAAK,OACH,MAAO,CAAC,OAAQ,SAClB,IAAK,SACH,MAAO,CAAC,IAAK,MAAO,OACtB,QACE,MAAO,G,CAIb,oBAAAuD,CAAqB7C,EAAeV,GAElC,OAAQA,GACN,IAAK,SAEH,cAAcU,IAAU,UAAYA,EAAME,SAAW,GACvD,IAAK,OACH,OAAOF,IAAU,QAAUA,IAAU,QACvC,IAAK,SACH,OAAQ8C,MAAMC,OAAO/C,IACvB,QACE,OAAO,M,CAIb,MAAAgD,GACE,OACEC,EAAA,OAAA1E,IAAA,2CAAK2E,MAAM,eACTD,EAAA,OAAA1E,IAAA,2CAAK2E,MAAM,iBACTD,EAAA,SAAA1E,IAAA,2CACEe,KAAK,OACL6D,IAAKC,GAAOrF,KAAKgD,SAAWqC,EAC5BF,MAAO,eAAenF,KAAKsF,aAC3BrD,MAAOjC,KAAKgC,WACZuD,QAAS,IAAMvF,KAAK6B,mBACpB2D,QAAStF,GAASF,KAAK+B,kBAAkB7B,GACzCuF,UAAWvF,GAASF,KAAKkC,cAAchC,GACvCwF,YAAY,uCAEdR,EAAA,OAAA1E,IAAA,2CAAK2E,MAAO,gBAAgBnF,KAAKM,mBAAqB,UAAY,MAC/DN,KAAKuE,YAAYC,KAAI5B,GACpBsC,EAAA,OAAKC,MAAM,aAAaQ,QAAS,IAAM3F,KAAK2C,sBAAsBC,IAC/DA,OAKTsC,EAAA,OAAA1E,IAAA,2CAAK2E,MAAM,QACRnF,KAAK4D,QAAQY,KAAI,CAACtB,EAAQa,IACzBmB,EAAA,QAAMC,MAAM,OACTjC,EACDgC,EAAA,UAAQ3D,KAAK,SAAS4D,MAAM,gBAAgBQ,QAAS,IAAM3F,KAAK8D,aAAaC,IAAM,S,8CCxRjG,MAAM6B,EAAgB,6eACtB,MAAAC,EAAeD,E,MCMFE,EAAU,M,kEAwCb9F,KAAAC,mBAAsBC,IAC5B,MAAM6F,EAAO/F,KAAKG,YAAY6F,WAC9B,GAAID,IAASA,EAAK3F,SAASF,EAAMG,QAAiB,CAChDL,KAAKM,mBAAqB,K,GAItBN,KAAAiG,gBAAmB/F,IACzB,GAAIA,EAAMM,MAAQ,SAAU,CAC1BR,KAAKM,mBAAqB,K,+EA5CA,G,iBACG,G,aACJ,G,wBACU,K,CAOvC,iBAAA4F,CAAkBC,GAChBnG,KAAKoG,YAAY5D,KAAK2D,E,CAKxB,uBAAM1F,GACJ,GAAIT,KAAKqG,IAAK,OACNrG,KAAKsG,W,CAEb,GAAItG,KAAKiC,MAAO,CACdjC,KAAKgC,WAAahC,KAAKiC,K,EAI3B,gBAAAd,GACEE,SAASK,iBAAiB,QAAS1B,KAAKC,oBACxCoB,SAASK,iBAAiB,UAAW1B,KAAKiG,gB,CAG5C,oBAAAtE,GACEN,SAASO,oBAAoB,QAAS5B,KAAKC,oBAC3CoB,SAASO,oBAAoB,UAAW5B,KAAKiG,gB,CAgB/C,eAAMK,GACJ,IACE,MAAMC,QAAiBC,MAAMxG,KAAKqG,KAClC,MAAMI,QAAaF,EAASE,OAC5BzG,KAAK0G,QAAUD,EACZ3D,MAAM,MACN0B,KAAImC,GAAQA,EAAKxE,SACjBe,QAAOyD,GAAQA,IAAS,I,CAC3B,MAAOzF,GACPF,QAAQE,MAAM,uBAAwBA,GACtClB,KAAK0G,QAAU,E,EAInB,gBAAA7E,GAEE,GAAI7B,KAAKgC,WAAWmB,OAAS,EAAG,CAC9BnD,KAAK8B,kBAAkB9B,KAAKgC,W,EAIhC,iBAAAD,CAAkB7B,GAChB,MAAM+B,EAAS/B,EAAMG,OAA4B4B,MACjDjC,KAAKgC,WAAaC,EAElB2E,aAAa5G,KAAK6G,eAClB7G,KAAK6G,cAAgBC,OAAOC,YAAW,KACrC/G,KAAK8B,kBAAkBG,EAAM,GAC5B,I,CAGL,aAAAC,CAAchC,G,CAOd,qBAAAyC,CAAsBC,GACpB5C,KAAKgC,WAAaY,EAClB5C,KAAKkG,kBAAkBtD,GACvB5C,KAAKgD,SAASf,MAAQW,EACtB5C,KAAKgD,SAASC,O,CAGhB,iBAAAnB,CAAkBkF,GAChB,GAAIA,EAAK7E,OAAOgB,SAAW,EAAG,CAE5BnD,KAAKuE,YAAc,GACnBvE,KAAKM,mBAAqB,K,KACrB,CACL,MAAM2G,EAAYD,EAAK1C,cACvB,MAAM4C,EAAWlH,KAAK0G,QAAQxD,QAAOyD,GAAQA,EAAKrC,cAAcO,SAASoC,KAEzEjH,KAAKuE,YAAc2C,EAASC,MAAM,EAAG,KACrCnH,KAAKM,mBAAqBN,KAAKuE,YAAYpB,OAAS,C,EAIxD,MAAA8B,GACE,OACEC,EAAA,OAAA1E,IAAA,2CAAK2E,MAAM,sBACTD,EAAA,OAAA1E,IAAA,2CAAK2E,MAAM,iBACTD,EAAA,SAAA1E,IAAA,2CACEe,KAAK,OACL6D,IAAKC,GAAOrF,KAAKgD,SAAWqC,EAC5BF,MAAM,iBACN3D,KAAMxB,KAAKwB,KACXS,MAAOjC,KAAKgC,WACZuD,QAAS,IAAMvF,KAAK6B,mBACpB2D,QAAStF,GAASF,KAAK+B,kBAAkB7B,GACzCuF,UAAWvF,GAASF,KAAKkC,cAAchC,GACvCwF,YAAY,sBAEdR,EAAA,OAAA1E,IAAA,2CAAK2E,MAAO,gBAAgBnF,KAAKM,mBAAqB,UAAY,MAC/DN,KAAKuE,YAAYC,KAAI5B,GACpBsC,EAAA,OAAKC,MAAM,aAAaQ,QAAS,IAAM3F,KAAK2C,sBAAsBC,IAC/DA,O,8CCzIjB,MAAMwE,EAAgB,63BACtB,MAAAC,EAAeD,E,MCMFE,EAAU,M,oGAIyC,G,yBACrB,G,qBACL,M,uBACC,G,wBACC,E,oBACJ,E,iBACoB,CAAEC,IAAK,EAAGC,KAAM,E,CAOtE,uBAAM/G,GACJ,MAAM8F,QAAiBC,MAAMxG,KAAKyH,eAClC,MAAMhB,QAAaF,EAASE,OAC5B,MAAMiB,EAAQjB,EACX3D,MAAM,MACN0B,KAAImD,GAAKA,EAAExF,SACXe,QAAOyE,GAAKA,EAAExE,OAAS,IAG1BnD,KAAKuE,YAAcmD,EAAMlD,KAAImD,IAAC,CAAOC,SAAUD,EAAGE,MAAOF,EAAErD,iB,CAI7D,aAAApC,CAAc4F,GACZ,IAAK9H,KAAK+H,gBAAiB,OAC3B,GAAID,EAAGtH,MAAQ,YAAa,CAC1BsH,EAAGE,iBACHhI,KAAKiI,gBAAkBjI,KAAKiI,eAAiB,GAAKjI,KAAKkI,oBAAoB/E,M,MACtE,GAAI2E,EAAGtH,MAAQ,UAAW,CAC/BsH,EAAGE,iBACHhI,KAAKiI,gBAAkBjI,KAAKiI,eAAiB,EAAIjI,KAAKkI,oBAAoB/E,QAAUnD,KAAKkI,oBAAoB/E,M,MACxG,GAAI2E,EAAGtH,MAAQ,QAAS,CAC7BsH,EAAGE,iBACHhI,KAAKmI,iBAAiBnI,KAAKkI,oBAAoBlI,KAAKiI,gB,MAC/C,GAAIH,EAAGtH,MAAQ,SAAU,CAC9BR,KAAK+H,gBAAkB,K,EAI3B,WAAAK,CAAYC,GACV,MAAMhI,EAASgI,EAAEhI,OACjBL,KAAKsI,kBAAoBjI,EAAO4B,MAEhC,MAAMsG,EAAWlI,EAAOmI,eACxB,MAAMC,EAAiBpI,EAAO4B,MAAMyG,UAAU,EAAGH,GACjD,MAAMI,EAASF,EAAeG,YAAY,KAE1C,GAAID,GAAU,EAAG,CACf,MAAMzE,EAAQuE,EAAeC,UAAUC,EAAS,GAAGrE,cAEnD,MAAM4C,EAAWlH,KAAKuE,YACnBrB,QAAOyE,GAAKA,EAAEE,MAAMpD,WAAWP,KAC/BiD,MAAM,EAAG,IACT3C,KAAImD,GAAKA,EAAEC,WAEd5H,KAAKkI,oBAAsBhB,EAC3BlH,KAAK+H,gBAAkBb,EAAS/D,OAAS,EACzCnD,KAAK6I,kBAAoBF,EACzB3I,KAAKiI,eAAiB,C,KACjB,CACLjI,KAAK+H,gBAAkB,K,CAIzB/H,KAAK8I,c,CAGP,YAAAA,GACE,IAAK9I,KAAK+I,YAAc/I,KAAKgJ,WAAY,OAEzC,MAAM/G,EAAQjC,KAAKsI,kBACnB,MAAMC,EAAWvI,KAAKgJ,WAAWR,eACjC,MAAMC,EAAiBxG,EAAMyG,UAAU,EAAGH,GAC1C,MAAMU,EAAkBhH,EAAMyG,UAAUH,GAGxC,MAAMW,EAAwBT,EAC3B9E,QAAQ,KAAM,SACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,QACdA,QAAQ,MAAO,UAGlB,MAAMwF,EAAgBD,EAAwB,yCAC5CD,EACGtF,QAAQ,KAAM,SACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,QACdA,QAAQ,MAAO,UAEpB3D,KAAK+I,UAAUK,UAAYD,EAG3B,MAAME,EAASrJ,KAAK+I,UAAUO,cAAc,iBAC5C,GAAID,EAAQ,CACV,MAAME,EAAaF,EAAOG,wBAC1B,MAAMC,EAAgBzJ,KAAKqF,GAAGW,WAAW0D,KAAKF,wBAC9CxJ,KAAK2J,YAAc,CACjBpC,IAAKgC,EAAWhC,IAAMkC,EAAclC,IACpCC,KAAM+B,EAAW/B,KAAOiC,EAAcjC,K,EAK5C,gBAAAW,CAAiBvF,GACf,MAAMX,EAAQjC,KAAKsI,kBACnB,MAAMsB,EAAgB3H,EAAMyG,UAAU,EAAG1I,KAAK6I,mBAC9C,MAAMN,EAAWvI,KAAKgJ,WAAWR,eACjC,MAAMqB,EAAa5H,EAAMyG,UAAUH,GACnC,MAAMpC,EAAWyD,EAAgB,IAAMhH,EAAa,IAAMiH,EAC1D7J,KAAKsI,kBAAoBnC,EACzBnG,KAAK+H,gBAAkB,MAEvB,MAAM+B,GAAeF,EAAgB,IAAMhH,EAAa,KAAKO,OAC7DnD,KAAKgJ,WAAW/G,MAAQkE,EACxBnG,KAAKgJ,WAAWe,kBAAkBD,EAAaA,GAC/C9J,KAAKgJ,WAAW/F,QAChBjD,KAAK8I,c,CAGP,gBAAA3H,GAEEnB,KAAK8I,c,CAGP,MAAA7D,GACE,MAAMsC,IAAEA,EAAGC,KAAEA,GAASxH,KAAK2J,YAC3B,OACEzE,EAAA,OAAA1E,IAAA,2CAAK2E,MAAM,yBACTD,EAAA,YAAA1E,IAAA,2CACE4E,IAAKC,GAAMrF,KAAKgJ,WAAa3D,EAC7BpD,MAAOjC,KAAKsI,kBACZ9C,QAAU6C,GAAMrI,KAAKoI,YAAYC,GACjClD,MAAO,qBAAqBnF,KAAKgK,kBAGnC9E,EAAA,OAAA1E,IAAA,2CAAK2E,MAAM,qBAAqBC,IAAKC,GAAMrF,KAAK+I,UAAY1D,IAE1DrF,KAAK+H,iBAAmB/H,KAAKkI,oBAAoB/E,OAAS,GAC1D+B,EAAA,MAAA1E,IAAA,2CACE2E,MAAM,0BACN8E,MAAO,CACLC,SAAU,WACV3C,IAAK,GAAGA,EAAM,OACdC,KAAM,GAAGA,OAEX2C,KAAK,WAEJnK,KAAKkI,oBAAoB1D,KAAI,CAAC4F,EAAMrG,IACnCmB,EAAA,MACEC,MAAO,CACL,8BAA+B,KAC/BkF,YAAetG,IAAU/D,KAAKiI,gBAEhCkC,KAAK,SACLxE,QAAS,IAAM3F,KAAKmI,iBAAiBiC,GACrCE,YAAa,IAAMtK,KAAKiI,eAAiBlE,GAExCqG,M","ignoreList":[]}